# 561. 数组拆分 I

### 题目描述

给定长度为 `2n` 的整数数组 `nums`，你的任务是将这些数分成 `n` 对, 例如 `(a1, b1), (a2, b2), ..., (an, bn)` ，使得从 `1` 到 `n` 的 `min(ai, bi)` 总和最大。

返回该 **最大总和** 。

示例 1：

```
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
```

示例 2：

```
输入：nums = [6,2,6,5,1,2]
输出：9
解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9
```

提示：

- `1 <= n <= 10^4`
- `nums.length == 2 * n`
- `-10^4 <= nums[i] <= 10^4`


### 思路

贪心法，对输入的数组 `nums` 进行排序，然后依次求相邻的两个元素的最小值，总和就是结果。时间复杂度为 `O(n*log n)`。

```go
func arrayPairSum(nums []int) int {
    ans := 0
    sort.Ints(nums)
    for i := 0; i < len(nums); i += 2 {
        ans += nums[i]
    }
    return ans
}
```

可以使用计数排序优化时间复杂度。先统计每个元素有多少个，如果当前元素是排序后的第奇数个，就加到最终答案里。

```go
func arrayPairSum(nums []int) int {
    cnt := [20001]int{}
    for _, num := range nums {
        cnt[num+10000]++
    }
    res := 0
    odd := 1
    for i := 0; i < 20001; i++ {
        if cnt[i] > 0 {
            res += (i - 10000) * ((cnt[i] + odd) / 2)
            odd = (odd + cnt[i]) % 2
        }
    }
    return res
}
```
