# 995. K 连续位的最小翻转次数

### 题目描述

在仅包含 `0` 和 `1` 的数组 `A` 中，一次 `K` 位翻转包括选择一个长度为 `K` 的（连续）子数组，同时将子数组中的每个 `0` 更改为 `1`，而每个 `1` 更改为 `0`。

返回所需的 `K` 位翻转的最小次数，以便数组没有值为 `0` 的元素。如果不可能，返回 `-1`。



示例 1：

```
输入：A = [0,1,0], K = 1
输出：2
解释：先翻转 A[0]，然后翻转 A[2]。
```

示例 2：

```
输入：A = [1,1,0], K = 2
输出：-1
解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。
```
示例 3：

```
输入：A = [0,0,0,1,0,1,1,0], K = 3
输出：3
解释：
翻转 A[0],A[1],A[2]:A变成 [1,1,1,1,0,1,1,0]
翻转 A[4],A[5],A[6]:A变成 [1,1,1,1,1,0,0,0]
翻转 A[5],A[6],A[7]:A变成 [1,1,1,1,1,1,1,1]
```

提示：

- `1 <= A.length <=30000`
- `1 <= K <= A.length`


### 思路

由于对同一个子数组执行两次翻转操作不会改变该子数组，所以对每个长度为 `K` 的子数组，应至多执行一次翻转操作。对于若干个 `K` 位翻转操作，改变先后顺序并不影响最终翻转的结果。

按照这一策略，我们从左到右地执行这些翻转操作。由于翻转操作是唯一的，若最终数组元素均为 `1`，则执行的翻转次数就是最小的。

用 `N` 表示数组 `A` 的长度。若直接模拟上述过程，复杂度将会是 `O(NK)` 的。因此使用队列模拟滑动窗口，该滑动窗口的含义是前面 `K−1` 个元素中，以哪些位置起始的子区间进行了翻转。该滑动窗口从左向右滑动，如果当前位置 `i` 需要翻转，则把该位置存储到队列中。遍历到新位置 `j (j < i + K)` 时，队列中元素的个数代表了 `j` 被前面 `K - 1` 个元素翻转的次数。

- 当 `i` 位置被翻转了偶数次，如果 `A[i]` 为 `0`，那么翻转后是 `0`，当前元素需要翻转；

- 当 `i` 位置被翻转了奇数次，如果 `A[i]` 为 `1`，那么翻转后是 `0`，当前元素需要翻转。


综合上面两点，我们得到一个结论，当 `len(que) % 2 == A[i]` 时，当前元素需要翻转。

```go
func minKBitFlips(A []int, K int) int {
    n := len(A)
    ans := 0
    var queue []int
    for i, v := range A {
        // 元素出队
        if len(queue) > 0 && queue[0] + K == i {
            queue = queue[1:]
        }
        // 需要翻转
        if len(queue) % 2 == v {
            // 超出范围，翻转失败
            if i + K > n {
                return -1
            }
            ans++
            // 元素入队
            queue = append(queue, i)
        }
    }
    return ans
}
```

